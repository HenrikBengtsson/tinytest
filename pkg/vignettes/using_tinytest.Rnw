%\VignetteIndexEntry{Using tinytest}
\documentclass[11pt]{article}
\usepackage{enumitem}
\setlist{nosep}

\usepackage{hyperref}

\hypersetup{
  pdfborder={0 0 0}
 , colorlinks=true 
 , urlcolor=red
 , linkcolor=blue
}

\renewcommand{\familydefault}{\sfdefault}


\title{Using tinytest}
\author{Mark van der Loo}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\pkg}[1]{\textbf{#1}}


\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}



\begin{document}
\newlength{\fancyvrbtopsep}
\newlength{\fancyvrbpartopsep}
\makeatletter
\FV@AddToHook{\FV@ListParameterHook}{\topsep=\fancyvrbtopsep\partopsep=\fancyvrbpartopsep}
\makeatother


\setlength{\fancyvrbtopsep}{0pt}
\setlength{\fancyvrbpartopsep}{0pt}
\maketitle{}

\tableofcontents{}
<<echo=FALSE>>=
options(prompt="    ", continue = "    ")
@


\section*{Before you read this}
I expect that readers of this document know how to write R functions. If you
want to use \pkg{tidytest} for your package, I expect that you have a basic
understanding of the directory structure that consitutes the source of an R
package.

\newpage{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Purpose of this package: unit testing}
The fundamental unit of code in R is a function. A function accepts one or more
arguments, executes some R code depending on the arguments, and returns a
result. 
<<>>=
inch2cm <- function(x){
	x*2.54
}
@
A function that is called by the user should usually only use data that is
passed as an argument, and it should also not alter anything outside of the
curly brackets (its scope). A function that satisfies these requirements is
called a \emph{pure function}.  You can \emph{in principle} define pure
functions by tabulating inputs and outputs.
<<>>=
inch2cmImpractical <- function(x){
  dat <- data.frame(inch=c(1,2,3),cm=c(2.54, 5.08, 7.62))
  dat$cm[dat$inch == x]
}
@
Since this is impractical to define functions as such, we write algorithms and
perform unit tests.

The purpose of \emph{unit testing} is to check whether a function gives the
output you expect, when it is provided with certain input. So unit testing is
all about comparing function outputs with expected outputs. The purpose of this
package is to facilitate writing unit tests, and to support a workflow of
writing tests while improving code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressing tests}
Suppose we define a function translating pounds (lbs) to kilograms.
<<>>=
lbs2kg <- function(x){
  if ( x < 0 ){
    stop(sprintf("Expected nonnegative weight, got %g",x))
  }
  x/2.20
}
@
We like to check a few things before we trust it.
<<>>=
library(tinytest)
expect_equal(1/2.2046, lbs2kg(1))
expect_error(lbs2kg(-3))
@

The value of an \code{expect\_*} function is a \code{logical}, with some
attributes that record differences, if there are any. These attributes are used
to pretty-print the results.
<<>>=
isTRUE( expect_true(2 == 1 + 1) )
@



\subsection{Test functions}
Currently, the following expectations are implemented.
\begin{center}
\begin{tabular}{ll}
\textbf{Function} & \textbf{what it does}\\
\code{expect\_equal(target, current)}      & test for exact equality\\
\code{expect\_equivalent(target, current)} & ignore attributes, e.g. names\\
\code{expect\_true(current)}            & `current' should evaluate to \code{TRUE}\\
\code{expect\_false(current)}           & `current' should evaluate to \code{FALSE}\\
\code{expect\_error(current, pattern)}           & expect an error message matching \code{pattern}\\
\code{expect\_warning(current, pattern)}         & expect a warning message matching \code{pattern}
\end{tabular}
\end{center}


\subsection{Interpreting the output}
Let's have a look at an example again.
<<>>=
expect_false( 1 + 1 == 2 )
@

The output of these functions is pretty self-explanatory, nevertheless we see that
the output of these expect-functions consist of
\begin{itemize}
\item The result: \code{FAILED} or \code{PASSED}.
  \item The type of failure (if any) between square brackets. Current options
       are as follows.
  \begin{itemize}
    \item \code{[data]} there are differences between observed and expected values.
    \item \code{[attr]} there are differences between observed and expected attributes, such as column names.
    \item \code{[xcpt]} an exception (warning, error) was expected but not observed. 
  \end{itemize}
  \item When relevant (see \S\ref{sect:testfiles}), the location of the test file and the relevant line numbers.
  \item When necessary, a summary of the differences between observed and expected
    values or attributes.
  \item The test call.
\end{itemize}
It is possible to print more prudent output, with a onliner for each test.
<<>>=
print(expect_equal(1+1, 3), type="short")
@
Tinytest will switch between long and short formats, depending on the workflow it
is used in. But you can always set 
<<eval=FALSE>>=
options(tt.print="long")
@
to force long (or \code{"short"} output. The default value is \code{"auto"}.


\section{Workflow}
Writing a function usually means you are working with two scripts.  In one
script, the function is developed, a second script prepares some data, calls
the function and you check the output interactively.  The idea of the
\pkg{tinytest} package is that you can very easily integrate those little test
scripts into a package (or just keep using them as part of a set of production
scripts).


\section{Test files}
\label{sect:testfiles}
In \pkg{tinytest}, tests are scripts, intersperced with statements that perform
checks. The workflow we promote is to write test files, and keep it handy so
you can rerun tests as you develop code (more on how to put them in a package
below).

An example test file in tinytest can look like this.


<<eval=FALSE>>=
library(tinytest)
m <- mean(women$height)
expect_equal(sum(women$height)/nrow(women), m)
@




\section{Testing packages}
The default testing structure is very simple. 

\begin{enumerate}
\item Testfiles are placed in \code{/inst/utst}. The testfiles all have
names starting with \code{test} (for example \code{test\_fu.R}).
\item In the file \code{/tests/tinytest.R} you place the code
<<eval=FALSE>>=
test_package("name of your package")
@
\end{enumerate}

Schematically, the package directory looks as follows (ignoring directories
like \code{man}).

\begin{itemize}
\hrule{}
  \item[]\code{R/}
  \item[]\code{inst/}
  \begin{itemize}
    \item[]{\textbf{\code{utst/}}}
    \begin{itemize}
      \item[]\code{test\_foo.R}
      \item[]\code{test\_bar.R}
      \item[]$\quad\vdots$
    \end{itemize}
  \end{itemize}
   \item[]{\code{tests/}}
     \begin{itemize}
       \item[]{\code{tinytest.R}}
     \end{itemize}
  \item[]{\code{DESCRIPTION}}
  \item[]{\code{NAMESPACE}}
\hrule{}
\end{itemize}





\subsection{Using data stored in files}
When your package is tested with \code{test\_package}, \pkg{tinytest} ensures
that your working directory is the testing directory (by default \code{utst}).
This means you can files that are stored in your folder directly.

Suppose that your package directory structure looks like this (default):
\begin{itemize}
\item[]\code{/inst}
  \begin{itemize}
    \item[]\code{/utst}
    \begin{itemize}
       \item[]\code{/test.R}
       \item[]\code{/women.csv}
    \end{itemize}
  \end{itemize}
\end{itemize}

Then, to check wether the contents of \code{women.csv} is equal to the 
built-in \code{women} dataset,  the content of \code{test.R} looks as follows.
<<eval=FALSE>>=
dat <- read.csv("women.csv")
expect_equal(women, dat)
@

\section{A few tips on packages and unit testing}


\subsection*{Make your package spherical}

Larger packages typically consist of a functions that are visible to the
users of that package (exported functions) as well as a bunch of functions
that are used by the exported functions. For example:

<<>>=
# exported, user-visible function
inch2cm <- function(x){
	x*conversion_factor("inch")
}
# not exported function, package-internal
conversion_factor <- function(unit){
	confac <- c(inch=2.54, pound=1/2.2056)
  confac[unit]
}
@

We can think of the exported functions as the \emph{surface} of your package,
and all the other functions as the \emph{volume}. The surface is what a user
sees, the volume is what the developer sees. The surface is how a user
interacts with a package. 


If the surface is small (few functions exported), users are limited in the ways
they can interact with your package, and that means there is less to test. So
as a rule of thumb, it is a good idea to keep the surface small. Since a sphere
has the smallest surface-to-volume ratio possible, I refer to this rule as
\emph{keep your package spherical}.

By the way, the technical term for the surface of a package is API (application
program interface).




\subsection*{Test the surface, not the volume}

Unexpected behavior (a bug) is often discovered when someone who is not the
developer starts using code. Bugfixing implies altering code and it may even
require you to refactor large chunks of code that is internal to a package.  If
you defined extensive tests on non-exported functions, this means you need to
rewrite the tests as well. As a rule of thumb, it is a good idea to test only
the behaviour at the surface, so as a developer you have more freedom to change
the internals. This includes rewriting and renaming internal functions completely.


By the way, it is bad practice to change the surface, since that means you are
going to break other people's code. Nobody likes to program against an API that
changes frequently, and everybody hates to program against an API that changes
unexpectedly.


\subsection*{A bug shall result in a test}
If users of your code are friendly enough to submit a bug report when they find
one, it is a good idea to start by writing a small test that reproduces the
error and add that to your test suite. That way, whenever you work on your
code, you can be sure to be alarmed when a bug reappears.

Tests that represent earlier bugs are sometimes called \emph{regression tests}.
If a bug reappears during development, software engineers sometimes refer
to this as a \emph{regression} (not linear regression, haha).











\end{document}
